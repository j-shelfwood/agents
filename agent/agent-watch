#!/bin/bash
# Watch Agent Sessions for State Changes
# Blocks until one or more agents require attention

set -e

# Source metadata utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/agent-metadata"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

AGENT_CMD="$HOME/.shelfwood/agent/agent"

# Usage function
usage() {
    cat << 'EOF'
Usage: agent watch [OPTIONS]

Watch all active agent sessions and block until state change detected.
Returns immediately when any agent completes, waits for input, or errors.

OPTIONS:
  --timeout <seconds>    Maximum wait time (default: 300s/5min, 0=infinite)
  --interval <seconds>   Polling interval (default: 3s)
  --sessions <names>     Watch specific sessions only (comma-separated)
  -h, --help             Show this help message

DETECTION TRIGGERS:
  - Agent completes task (copilot exits)
  - Agent waiting for input (output stops, contains question marks)
  - Agent encounters error (stderr output)
  - New output detected (activity change)

OUTPUT FORMAT:
  STATUS: <COMPLETED|WAITING|ERROR|ACTIVE>
  SESSION: <session-name>
  MESSAGE: <relevant context>
  TIMESTAMP: <when detected>

EXAMPLES:

# Watch all agents until one needs attention
agent watch

# Watch with 10 minute timeout
agent watch --timeout 600

# Watch specific agents only
agent watch --sessions agent-myapp-1234,agent-myapp-5678

# Fast polling for quick tasks (1 second interval)
agent watch --interval 1

WORKFLOW INTEGRATION:

# Spawn multiple agents
agent spawn ~/project tasks/task1.md
agent spawn ~/project tasks/task2.md
agent spawn ~/project tasks/task3.md

# Watch until first state change
agent watch
# → Returns: SESSION: agent-project-1234 | STATUS: COMPLETED

# Handle completion
agent read agent-project-1234
agent kill agent-project-1234

# Watch for next state change
agent watch
# → Returns: SESSION: agent-project-5678 | STATUS: WAITING

# Respond to waiting agent
agent send agent-project-5678 "Continue with option A"

# Continue watching...
agent watch
EOF
    exit 0
}

# Parse arguments
TIMEOUT=300
INTERVAL=3
SPECIFIC_SESSIONS=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        --interval)
            INTERVAL="$2"
            shift 2
            ;;
        --sessions)
            SPECIFIC_SESSIONS="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo -e "${RED}Error: Unknown option: $1${NC}"
            usage
            ;;
    esac
done

echo -e "${BLUE}╔════════════════════════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║${NC}  ${GREEN}Watching Agent Sessions${NC}                               ${BLUE}║${NC}"
echo -e "${BLUE}╚════════════════════════════════════════════════════════════════╝${NC}"
echo ""

# Get list of sessions to watch
if [[ -n "$SPECIFIC_SESSIONS" ]]; then
    IFS=',' read -ra SESSIONS <<< "$SPECIFIC_SESSIONS"

    # Validate each session name
    for session in "${SESSIONS[@]}"; do
        if ! validate_session_name "$session"; then
            exit 1
        fi
    done

    echo -e "${CYAN}Watching:${NC}  ${SESSIONS[*]}"
else
    # Get all tmux sessions and filter for copilot (bash 3.2 compatible)
    SESSIONS=()
    while IFS= read -r session; do
        # Check if session is running copilot (use -S for scrollback)
        if tmux capture-pane -t "$session" -p -S -100 2>/dev/null | grep -q "GitHub Copilot CLI"; then
            SESSIONS+=("$session")
        fi
    done < <(tmux list-sessions -F "#{session_name}" 2>/dev/null || true)

    if [[ ${#SESSIONS[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No active agent sessions found${NC}"
        exit 1
    fi

    echo -e "${CYAN}Watching:${NC}  ${#SESSIONS[@]} active sessions"
fi

echo -e "${CYAN}Timeout:${NC}   ${TIMEOUT}s ($(($TIMEOUT / 60)) minutes)"
echo -e "${CYAN}Interval:${NC}  ${INTERVAL}s"
echo ""
echo -e "${YELLOW}Monitoring for state changes...${NC}"
echo ""

# Store initial state in temp files (bash 3.2 compatible)
TMPDIR="${TMPDIR:-/tmp}"
STATE_DIR=$(mktemp -d "$TMPDIR/agent-watch.XXXXXX")
trap "rm -rf '$STATE_DIR'" EXIT

for session in "${SESSIONS[@]}"; do
    if tmux has-session -t "$session" 2>/dev/null; then
        # Capture last 10 lines as baseline
        tmux capture-pane -t "$session" -p -S -10 2>/dev/null > "$STATE_DIR/$session.initial" || echo "" > "$STATE_DIR/$session.initial"
    fi
done

# Watch loop
START_TIME=$(date +%s)
ELAPSED=0

while [[ $TIMEOUT -eq 0 || $ELAPSED -lt $TIMEOUT ]]; do
    for session in "${SESSIONS[@]}"; do
        # Check if session still exists
        if ! tmux has-session -t "$session" 2>/dev/null; then
            # Session terminated (agent completed or crashed)
            echo -e "${GREEN}╔════════════════════════════════════════════════════════════════╗${NC}"
            echo -e "${GREEN}║${NC}  ${YELLOW}State Change Detected${NC}                                 ${GREEN}║${NC}"
            echo -e "${GREEN}╚════════════════════════════════════════════════════════════════╝${NC}"
            echo ""
            echo -e "${CYAN}Session:${NC}   $session"
            echo -e "${CYAN}Status:${NC}    ${MAGENTA}COMPLETED${NC} (session terminated)"
            echo -e "${CYAN}Time:${NC}      ${ELAPSED}s since watch started"
            echo ""
            exit 0
        fi

        # Capture current output
        CURRENT_OUTPUT=$(tmux capture-pane -t "$session" -p -S -10 2>/dev/null || echo "")

        # Check if output changed (new activity)
        if [[ -f "$STATE_DIR/$session.initial" ]]; then
            INITIAL_OUTPUT=$(cat "$STATE_DIR/$session.initial")
        else
            INITIAL_OUTPUT=""
        fi

        if [[ "$CURRENT_OUTPUT" != "$INITIAL_OUTPUT" ]]; then
            # Get the new content
            NEW_LINES=$(comm -13 <(echo "$INITIAL_OUTPUT" | sort) <(echo "$CURRENT_OUTPUT" | sort))

            # Check for waiting indicators
            if echo "$NEW_LINES" | grep -qiE "\(y/n\)|\?$|continue\?|proceed\?|waiting|allow|confirm|choose"; then
                echo -e "${GREEN}╔════════════════════════════════════════════════════════════════╗${NC}"
                echo -e "${GREEN}║${NC}  ${YELLOW}State Change Detected${NC}                                 ${GREEN}║${NC}"
                echo -e "${GREEN}╚════════════════════════════════════════════════════════════════╝${NC}"
                echo ""
                echo -e "${CYAN}Session:${NC}   $session"
                echo -e "${CYAN}Status:${NC}    ${YELLOW}WAITING_FOR_INPUT${NC}"
                echo -e "${CYAN}Time:${NC}      ${ELAPSED}s since watch started"
                echo ""
                echo -e "${CYAN}Recent output:${NC}"
                echo "$NEW_LINES" | tail -5
                echo ""
                exit 0
            fi

            # Check for error indicators
            if echo "$NEW_LINES" | grep -qiE "error:|failed|exception|fatal|cannot|unable to"; then
                echo -e "${GREEN}╔════════════════════════════════════════════════════════════════╗${NC}"
                echo -e "${GREEN}║${NC}  ${YELLOW}State Change Detected${NC}                                 ${GREEN}║${NC}"
                echo -e "${GREEN}╚════════════════════════════════════════════════════════════════╝${NC}"
                echo ""
                echo -e "${CYAN}Session:${NC}   $session"
                echo -e "${CYAN}Status:${NC}    ${RED}ERROR${NC}"
                echo -e "${CYAN}Time:${NC}      ${ELAPSED}s since watch started"
                echo ""
                echo -e "${CYAN}Error output:${NC}"
                echo "$NEW_LINES" | grep -iE "error:|failed|exception" | tail -5
                echo ""
                exit 0
            fi

            # Update baseline for this session
            echo "$CURRENT_OUTPUT" > "$STATE_DIR/$session.initial"
        fi
    done

    # Wait before next check
    sleep "$INTERVAL"

    # Update elapsed time
    CURRENT_TIME=$(date +%s)
    ELAPSED=$((CURRENT_TIME - START_TIME))

    # Show progress indicator every 30 seconds
    if [[ $((ELAPSED % 30)) -eq 0 && $ELAPSED -gt 0 ]]; then
        echo -e "${CYAN}[${ELAPSED}s]${NC} Still watching ${#SESSIONS[@]} sessions..."
    fi
done

# Timeout reached
echo -e "${YELLOW}╔════════════════════════════════════════════════════════════════╗${NC}"
echo -e "${YELLOW}║${NC}  ${CYAN}Watch Timeout${NC}                                          ${YELLOW}║${NC}"
echo -e "${YELLOW}╚════════════════════════════════════════════════════════════════╝${NC}"
echo ""
echo -e "${CYAN}Timeout:${NC}  ${TIMEOUT}s reached with no state changes"
echo ""
echo -e "${YELLOW}All agents still running:${NC}"
for session in "${SESSIONS[@]}"; do
    if tmux has-session -t "$session" 2>/dev/null; then
        echo -e "  ${CYAN}•${NC} $session"
    fi
done
echo ""
exit 2
