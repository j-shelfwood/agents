#!/usr/bin/env bash
# agent-metadata - Metadata management utilities for agent sessions
# Sourced by agent commands to handle session metadata

METADATA_DIR="$HOME/.shelfwood/agent/metadata"
METADATA_ARCHIVE_DIR="$HOME/.shelfwood/agent/metadata/archive"

# Ensure metadata directories exist
mkdir -p "$METADATA_DIR"
mkdir -p "$METADATA_ARCHIVE_DIR"

# Validate session name format
# Usage: validate_session_name SESSION_NAME
# Returns: 0 if valid, 1 if invalid (with error message to stderr)
validate_session_name() {
    local session="$1"

    if [[ -z "$session" ]]; then
        echo "Error: Session name is required" >&2
        return 1
    fi

    # Only allow alphanumeric, dash, underscore
    if [[ ! "$session" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo "Error: Invalid session name '$session'" >&2
        echo "Session names must contain only letters, numbers, dashes, and underscores" >&2
        return 1
    fi

    # Length check
    if [[ ${#session} -gt 100 ]]; then
        echo "Error: Session name too long (max 100 characters)" >&2
        return 1
    fi

    return 0
}

# Create metadata file for a session
# Usage: create_metadata SESSION_NAME PROJECT_DIR TASK_FILE PID [IMPORTANCE] [NOTES]
create_metadata() {
    local session="$1"
    local project_dir="$2"
    local task_file="$3"
    local pid="$4"
    local importance="${5:-normal}"
    local notes="${6:-}"
    local spawned_by="${CLAUDE_CODE_SESSION_ID:-manual}"

    local metadata_file="$METADATA_DIR/${session}.json"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    cat > "$metadata_file" <<EOF
{
  "session_id": "$session",
  "project_dir": "$project_dir",
  "task_file": "$task_file",
  "spawned_at": "$timestamp",
  "spawned_by": "$spawned_by",
  "status": "running",
  "importance": "$importance",
  "tags": [],
  "pid": $pid,
  "last_activity": "$timestamp",
  "health_checks": {
    "last_check": "$timestamp",
    "consecutive_failures": 0
  },
  "notes": "$notes",
  "resume_chain": []
}
EOF
    echo "$metadata_file"
}

# Update metadata field
# Usage: update_metadata SESSION_NAME FIELD VALUE
update_metadata() {
    local session="$1"
    local field="$2"
    local value="$3"
    local metadata_file="$METADATA_DIR/${session}.json"

    if [[ ! -f "$metadata_file" ]]; then
        return 1
    fi

    # Use jq if available, otherwise use sed for simple updates
    if command -v jq &>/dev/null; then
        local tmp=$(mktemp)
        jq --arg val "$value" ".${field} = \$val" "$metadata_file" > "$tmp" && mv "$tmp" "$metadata_file"
    else
        # Fallback for simple string replacements
        sed -i.bak "s|\"${field}\": \"[^\"]*\"|\"${field}\": \"${value}\"|" "$metadata_file"
        rm -f "${metadata_file}.bak"
    fi
}

# Get metadata field value
# Usage: get_metadata SESSION_NAME FIELD
get_metadata() {
    local session="$1"
    local field="$2"
    local metadata_file="$METADATA_DIR/${session}.json"

    if [[ ! -f "$metadata_file" ]]; then
        return 1
    fi

    if command -v jq &>/dev/null; then
        jq -r ".${field}" "$metadata_file" 2>/dev/null
    else
        # Fallback: grep and sed
        grep "\"${field}\"" "$metadata_file" | sed -E 's/.*"'"$field"'": "?([^",}]*)"?.*/\1/' | tr -d ' '
    fi
}

# Check if metadata exists
# Usage: has_metadata SESSION_NAME
has_metadata() {
    local session="$1"
    [[ -f "$METADATA_DIR/${session}.json" ]]
}

# Detect session health state
# Usage: detect_session_state SESSION_NAME
# Returns: running|crashed|zombie|missing
detect_session_state() {
    local session="$1"

    # Check if tmux session exists
    if ! tmux has-session -t "$session" 2>/dev/null; then
        if has_metadata "$session"; then
            echo "missing"
        else
            echo "unknown"
        fi
        return
    fi

    # Check if pane is valid
    if ! tmux list-panes -t "$session" >/dev/null 2>&1; then
        echo "zombie"
        return
    fi

    # Get pane PID
    local pid=$(tmux list-panes -t "$session" -F "#{pane_pid}" 2>/dev/null | head -1)

    if [[ -z "$pid" ]]; then
        echo "zombie"
        return
    fi

    # Check if copilot process is running
    local cmd=$(ps -p "$pid" -o command= 2>/dev/null)

    if [[ "$cmd" == *"bin/copilot"* && "$cmd" == *"--add-dir"* ]]; then
        echo "running"
    elif [[ -n "$cmd" ]]; then
        echo "crashed"
    else
        echo "zombie"
    fi
}

# Update last activity timestamp
# Usage: touch_metadata SESSION_NAME
touch_metadata() {
    local session="$1"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    update_metadata "$session" "last_activity" "$timestamp"
}

# Archive metadata (move to archive directory)
# Usage: archive_metadata SESSION_NAME
archive_metadata() {
    local session="$1"
    local metadata_file="$METADATA_DIR/${session}.json"

    if [[ -f "$metadata_file" ]]; then
        local timestamp=$(date +"%Y%m%d_%H%M%S")
        mv "$metadata_file" "$METADATA_ARCHIVE_DIR/${session}_${timestamp}.json"
    fi
}

# Add note to metadata
# Usage: add_note SESSION_NAME "note text"
add_note() {
    local session="$1"
    local note="$2"
    update_metadata "$session" "notes" "$note"
}

# Add tag to metadata
# Usage: add_tag SESSION_NAME TAG
add_tag() {
    local session="$1"
    local tag="$2"
    local metadata_file="$METADATA_DIR/${session}.json"

    if [[ ! -f "$metadata_file" ]]; then
        return 1
    fi

    if command -v jq &>/dev/null; then
        local tmp=$(mktemp)
        jq --arg tag "$tag" '.tags += [$tag] | .tags |= unique' "$metadata_file" > "$tmp" && mv "$tmp" "$metadata_file"
    fi
}

# Set importance level
# Usage: set_importance SESSION_NAME LEVEL
set_importance() {
    local session="$1"
    local level="$2"
    update_metadata "$session" "importance" "$level"
}

# List all metadata files
# Usage: list_metadata
list_metadata() {
    find "$METADATA_DIR" -maxdepth 1 -name "*.json" -type f 2>/dev/null | while read -r file; do
        basename "$file" .json
    done
}

# Clean up stale metadata (sessions that no longer exist)
# Usage: cleanup_stale_metadata [--force]
cleanup_stale_metadata() {
    local force=false
    if [[ "$1" == "--force" ]]; then
        force=true
    fi

    local stale_count=0
    local protected_count=0

    while read -r session; do
        local state=$(detect_session_state "$session")
        local importance=$(get_metadata "$session" "importance")

        if [[ "$state" == "missing" || "$state" == "zombie" ]]; then
            if [[ "$importance" == "critical" && "$force" != "true" ]]; then
                ((protected_count++))
                continue
            fi

            archive_metadata "$session"
            ((stale_count++))
        fi
    done < <(list_metadata)

    echo "Cleaned up $stale_count stale sessions"
    if [[ $protected_count -gt 0 ]]; then
        echo "Skipped $protected_count protected critical sessions (use --force)"
    fi
}

# Clean old archived metadata
# Usage: clean_archive DAYS [--force]
clean_archive() {
    local days="${1:-90}"
    local force=false

    if [[ "$2" == "--force" ]]; then
        force=true
    fi

    if [[ ! -d "$METADATA_ARCHIVE_DIR" ]]; then
        echo "No archive directory found"
        return 0
    fi

    echo "Searching for archive files older than $days days..."

    local count=0
    local total_size=0

    # Find files older than N days
    while IFS= read -r file; do
        local size=$(stat -f%z "$file" 2>/dev/null || echo 0)
        total_size=$((total_size + size))
        ((count++))

        if [[ "$force" == "true" ]]; then
            rm -f "$file"
            echo "  Deleted: $(basename "$file")"
        else
            echo "  Would delete: $(basename "$file")"
        fi
    done < <(find "$METADATA_ARCHIVE_DIR" -name "*.json" -type f -mtime +${days} 2>/dev/null)

    if [[ $count -eq 0 ]]; then
        echo "No files found older than $days days"
        return 0
    fi

    local size_kb=$((total_size / 1024))

    if [[ "$force" == "true" ]]; then
        echo "Deleted $count files ($size_kb KB)"
    else
        echo "Found $count files ($size_kb KB) - use --force to delete"
    fi
}

# CLI interface (when executed directly)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    case "${1:-}" in
        --archive-stale|archive-stale)
            cleanup_stale_metadata "${@:2}"
            ;;
        --clean-archive|clean-archive)
            clean_archive "${@:2}"
            ;;
        --list|list)
            list_metadata
            ;;
        --help|help|-h|"")
            cat << 'EOF'
agent-metadata - Metadata management utilities

USAGE:
  agent-metadata <command> [options]

COMMANDS:
  archive-stale [--force]         Move completed sessions to archive
  clean-archive [DAYS] [--force]  Delete archive files older than DAYS (default: 90)
  list                            List all active metadata files
  help                            Show this help message

EXAMPLES:
  agent-metadata archive-stale           # Move completed sessions to archive
  agent-metadata clean-archive 30        # Show files older than 30 days
  agent-metadata clean-archive 90 --force  # Delete files older than 90 days
  agent-metadata list                    # List active metadata

LOCATIONS:
  Active:  ~/.shelfwood/agent/metadata/
  Archive: ~/.shelfwood/agent/metadata/archive/

EOF
            ;;
        *)
            echo "Unknown command: $1" >&2
            echo "Run 'agent-metadata help' for usage" >&2
            exit 1
            ;;
    esac
fi
