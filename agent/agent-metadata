#!/usr/bin/env bash
# agent-metadata - Metadata management utilities for agent sessions
# Sourced by agent commands to handle session metadata

# Source configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../src/lib/config.sh"

# Set legacy variable for compatibility
METADATA_DIR="$AGENT_METADATA_DIR"
METADATA_ARCHIVE_DIR="$AGENT_METADATA_ARCHIVE_DIR"

# Validate session name format
# Usage: validate_session_name SESSION_NAME
# Returns: 0 if valid, 1 if invalid (with error message to stderr)
validate_session_name() {
    local session="$1"

    if [[ -z "$session" ]]; then
        echo "Error: Session name is required" >&2
        return 1
    fi

    # Only allow alphanumeric, dash, underscore
    if [[ ! "$session" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo "Error: Invalid session name '$session'" >&2
        echo "Session names must contain only letters, numbers, dashes, and underscores" >&2
        return 1
    fi

    # Length check
    if [[ ${#session} -gt 100 ]]; then
        echo "Error: Session name too long (max 100 characters)" >&2
        return 1
    fi

    return 0
}

# Create metadata file for a session
# Usage: create_metadata SESSION_NAME PROJECT_DIR TASK_FILE PID [IMPORTANCE] [NOTES] [TTL_MINUTES]
create_metadata() {
    local session="$1"
    local project_dir="$2"
    local task_file="$3"
    local pid="$4"
    local importance="${5:-normal}"
    local notes="${6:-}"
    local ttl_minutes="${7:-60}"
    local spawned_by="${CLAUDE_CODE_SESSION_ID:-manual}"

    local metadata_file="$METADATA_DIR/${session}.json"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Convert TTL to seconds for internal use
    local ttl_seconds=$((ttl_minutes * 60))

    cat > "$metadata_file" <<EOF
{
  "session_id": "$session",
  "project_dir": "$project_dir",
  "task_file": "$task_file",
  "spawned_at": "$timestamp",
  "spawned_by": "$spawned_by",
  "status": "running",
  "importance": "$importance",
  "tags": [],
  "pid": $pid,
  "last_activity": "$timestamp",
  "last_output_hash": "",
  "consecutive_stale_checks": 0,
  "ttl_seconds": $ttl_seconds,
  "ttl_enabled": $([ "$ttl_minutes" -gt 0 ] && echo "true" || echo "false"),
  "health_checks": {
    "last_check": "$timestamp",
    "consecutive_failures": 0
  },
  "notes": "$notes",
  "resume_chain": []
}
EOF
    echo "$metadata_file"
}

# Update metadata field
# Usage: update_metadata SESSION_NAME FIELD VALUE
update_metadata() {
    local session="$1"
    local field="$2"
    local value="$3"
    local metadata_file="$METADATA_DIR/${session}.json"

    if [[ ! -f "$metadata_file" ]]; then
        return 1
    fi

    # Use jq if available, otherwise use sed for simple updates
    if command -v jq &>/dev/null; then
        local tmp=$(mktemp)
        jq --arg val "$value" ".${field} = \$val" "$metadata_file" > "$tmp" && mv "$tmp" "$metadata_file"
    else
        # Fallback for simple string replacements
        sed -i.bak "s|\"${field}\": \"[^\"]*\"|\"${field}\": \"${value}\"|" "$metadata_file"
        rm -f "${metadata_file}.bak"
    fi
}

# Get metadata field value
# Usage: get_metadata SESSION_NAME FIELD
get_metadata() {
    local session="$1"
    local field="$2"
    local metadata_file="$METADATA_DIR/${session}.json"

    if [[ ! -f "$metadata_file" ]]; then
        return 1
    fi

    if command -v jq &>/dev/null; then
        jq -r ".${field}" "$metadata_file" 2>/dev/null
    else
        # Fallback: grep and sed
        grep "\"${field}\"" "$metadata_file" | sed -E 's/.*"'"$field"'": "?([^",}]*)"?.*/\1/' | tr -d ' '
    fi
}

# Check if metadata exists
# Usage: has_metadata SESSION_NAME
has_metadata() {
    local session="$1"
    [[ -f "$METADATA_DIR/${session}.json" ]]
}

# Detect session health state
# Usage: detect_session_state SESSION_NAME
# Returns: running|crashed|zombie|missing
detect_session_state() {
    local session="$1"

    # Check if tmux session exists
    if ! tmux has-session -t "$session" 2>/dev/null; then
        if has_metadata "$session"; then
            echo "missing"
        else
            echo "unknown"
        fi
        return
    fi

    # Check if pane is valid
    if ! tmux list-panes -t "$session" >/dev/null 2>&1; then
        echo "zombie"
        return
    fi

    # Get pane PID
    local pid=$(tmux list-panes -t "$session" -F "#{pane_pid}" 2>/dev/null | head -1)

    if [[ -z "$pid" ]]; then
        echo "zombie"
        return
    fi

    # Check if copilot process is running
    local cmd=$(ps -p "$pid" -o command= 2>/dev/null)

    if [[ "$cmd" == *"bin/copilot"* && "$cmd" == *"--add-dir"* ]]; then
        echo "running"
    elif [[ -n "$cmd" ]]; then
        echo "crashed"
    else
        echo "zombie"
    fi
}

# ============================================================================
# OS-Level State Detection (Point 2 Architecture)
# ============================================================================

# Detect process activity via child process tree
# Usage: detect_process_activity SESSION_NAME
# Returns: EXECUTING_TOOL|THINKING|IDLE
detect_process_activity() {
    local session="$1"
    local pane_pid=$(tmux list-panes -t "$session" -F "#{pane_pid}" 2>/dev/null | head -1)

    if [[ -z "$pane_pid" ]]; then
        echo "IDLE"
        return
    fi

    # Count child processes (tools being executed)
    local child_count=$(pgrep -P "$pane_pid" 2>/dev/null | wc -l | tr -d ' ')

    if [[ $child_count -gt 0 ]]; then
        echo "EXECUTING_TOOL"
        return
    fi

    # No children - check CPU for thinking vs idle
    local cpu_usage=$(ps -p "$pane_pid" -o %cpu= 2>/dev/null | awk '{print int($1)}')

    if [[ -n "$cpu_usage" && $cpu_usage -gt 10 ]]; then
        echo "THINKING"
    else
        echo "IDLE"
    fi
}

# Detect cursor state (prompt visible at bottom)
# Usage: detect_cursor_state SESSION_NAME
# Returns: PROMPT_VISIBLE|NO_PROMPT
detect_cursor_state() {
    local session="$1"

    # Get cursor position, pane dimensions, and last line in ONE tmux call (optimized)
    local cursor_info=$(tmux display-message -p -t "$session" '#{cursor_y},#{pane_height}' 2>/dev/null)
    if [[ -z "$cursor_info" ]]; then
        echo "NO_PROMPT"
        return
    fi

    IFS=',' read -r cursor_y pane_height <<< "$cursor_info"

    # Only check bottom lines if cursor is near bottom (lenient threshold for trailing blanks)
    if [[ $cursor_y -ge $((pane_height - 6)) ]]; then
        # Check last non-empty line to handle trailing blanks from Copilot CLI
        local last_nonempty=$(tmux capture-pane -t "$session" -p | grep -v '^[[:space:]]*$' | tail -1)
        if [[ "$last_nonempty" =~ (^\>\ $|Ctrl\+c\ Exit|Remaining\ requests:) ]]; then
            echo "PROMPT_VISIBLE"
            return
        fi
    fi

    echo "NO_PROMPT"
}

# Check for sentinel completion file
# Usage: detect_completion_signal SESSION_NAME
# Returns: COMPLETED|RUNNING
detect_completion_signal() {
    local session="$1"
    local sentinel_file="${AGENT_HOME}/sentinel/${session}.completed"

    if [[ -f "$sentinel_file" ]]; then
        echo "COMPLETED"
        return
    fi

    # Fallback: tmux session existence
    if ! tmux has-session -t "$session" 2>/dev/null; then
        echo "COMPLETED"
        return
    fi

    echo "RUNNING"
}

# Get semantic output hash (strip ANSI codes and UI chrome)
# Usage: get_semantic_output_hash SESSION_NAME
get_semantic_output_hash() {
    local session="$1"

    if ! tmux has-session -t "$session" 2>/dev/null; then
        echo ""
        return 1
    fi

    # Capture, strip ANSI, filter UI chrome, hash
    tmux capture-pane -t "$session" -p -S -50 2>/dev/null \
        | sed 's/\x1b\[[0-9;]*m//g' \
        | grep -v "^Remaining requests:" \
        | grep -v "^Ctrl+c Exit" \
        | md5sum 2>/dev/null | cut -d' ' -f1 || echo ""
}

# Transition state with logging
# Usage: transition_state SESSION_NAME NEW_STATE
transition_state() {
    local session="$1"
    local new_state="$2"
    local old_state=$(get_metadata "$session" "status" 2>/dev/null || echo "unknown")

    if [[ "$old_state" != "$new_state" ]]; then
        update_metadata "$session" "status" "$new_state"
        local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

        # Log state transition (for debugging)
        if [[ -n "${AGENT_HOME}" && -d "${AGENT_HOME}" ]]; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] State transition: $session: $old_state â†’ $new_state" >> "${AGENT_HOME}/state-transitions.log" 2>/dev/null || true
        fi
    fi
}

# Unified state machine (replaces detect_agent_activity)
# Usage: update_agent_state SESSION_NAME
# Side effect: Updates metadata status field
# Returns: Current state for convenience
update_agent_state() {
    local session="$1"

    # 1. Check sentinel file first
    local completion_signal=$(detect_completion_signal "$session")
    if [[ "$completion_signal" == "COMPLETED" ]]; then
        transition_state "$session" "completed"
        echo "completed"
        return 0
    fi

    # 2. Check process tree
    local process_state=$(detect_process_activity "$session")
    if [[ "$process_state" == "EXECUTING_TOOL" || "$process_state" == "THINKING" ]]; then
        transition_state "$session" "active"
        update_metadata "$session" "consecutive_stale_checks" "0"
        update_metadata "$session" "last_activity" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        echo "active"
        return 0
    fi

    # 3. Check for errors in recent output (still useful for error detection)
    local recent_output=$(tmux capture-pane -t "$session" -p -S -10 2>/dev/null || echo "")
    if echo "$recent_output" | grep -qiE "^error:|^fatal:|exception:|command failed"; then
        transition_state "$session" "error"
        echo "error"
        return 0
    fi

    # 4. Check cursor position FIRST if process is IDLE (fast path for WAITING detection)
    if [[ "$process_state" == "IDLE" ]]; then
        local cursor_state=$(detect_cursor_state "$session")
        if [[ "$cursor_state" == "PROMPT_VISIBLE" ]]; then
            # Update hash and activity timestamp even when waiting
            local current_hash=$(get_semantic_output_hash "$session")
            if [[ -n "$current_hash" ]]; then
                update_metadata "$session" "last_output_hash" "$current_hash"
            fi
            update_metadata "$session" "last_activity" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            update_metadata "$session" "consecutive_stale_checks" "0"
            transition_state "$session" "waiting_for_input"
            echo "waiting_for_input"
            return 0
        fi
    fi

    # 5. Check semantic hash for output changes
    local current_hash=$(get_semantic_output_hash "$session")
    local stored_hash=$(get_metadata "$session" "last_output_hash" 2>/dev/null || echo "")

    if [[ -n "$current_hash" && "$current_hash" != "$stored_hash" ]]; then
        # Output changed - still active
        update_metadata "$session" "last_output_hash" "$current_hash"
        update_metadata "$session" "last_activity" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        update_metadata "$session" "consecutive_stale_checks" "0"
        transition_state "$session" "active"
        echo "active"
        return 0
    fi

    # 6. No changes detected - increment stale counter
    local stale_count=$(get_metadata "$session" "consecutive_stale_checks" 2>/dev/null || echo "0")
    stale_count=$((stale_count + 1))
    update_metadata "$session" "consecutive_stale_checks" "$stale_count"

    # 7. Determine state based on stale count
    if [[ $stale_count -ge 5 ]]; then
        # Stuck for 5+ checks - likely frozen
        transition_state "$session" "stuck"
        echo "stuck"
    else
        # Still within grace period - assume active
        transition_state "$session" "active"
        echo "active"
    fi

    return 0
}

# Legacy compatibility wrapper (for gradual migration)
# Usage: detect_agent_activity SESSION_NAME
# Returns: waiting_for_input|error|active|completed
detect_agent_activity() {
    local session="$1"
    update_agent_state "$session"
}

# Update last activity timestamp
# Usage: touch_metadata SESSION_NAME
touch_metadata() {
    local session="$1"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    update_metadata "$session" "last_activity" "$timestamp"
}

# Archive metadata (move to archive directory)
# Usage: archive_metadata SESSION_NAME
archive_metadata() {
    local session="$1"
    local metadata_file="$METADATA_DIR/${session}.json"

    if [[ -f "$metadata_file" ]]; then
        local timestamp=$(date +"%Y%m%d_%H%M%S")
        mv "$metadata_file" "$METADATA_ARCHIVE_DIR/${session}_${timestamp}.json"
    fi
}

# Add note to metadata
# Usage: add_note SESSION_NAME "note text"
add_note() {
    local session="$1"
    local note="$2"
    update_metadata "$session" "notes" "$note"
}

# Add tag to metadata
# Usage: add_tag SESSION_NAME TAG
add_tag() {
    local session="$1"
    local tag="$2"
    local metadata_file="$METADATA_DIR/${session}.json"

    if [[ ! -f "$metadata_file" ]]; then
        return 1
    fi

    if command -v jq &>/dev/null; then
        local tmp=$(mktemp)
        jq --arg tag "$tag" '.tags += [$tag] | .tags |= unique' "$metadata_file" > "$tmp" && mv "$tmp" "$metadata_file"
    fi
}

# Set importance level
# Usage: set_importance SESSION_NAME LEVEL
set_importance() {
    local session="$1"
    local level="$2"
    update_metadata "$session" "importance" "$level"
}

# List all metadata files
# Usage: list_metadata
list_metadata() {
    find "$METADATA_DIR" -maxdepth 1 -name "*.json" -type f 2>/dev/null | while read -r file; do
        basename "$file" .json
    done
}

# Clean up stale metadata (sessions that no longer exist)
# Usage: cleanup_stale_metadata [--force]
cleanup_stale_metadata() {
    local force=false
    if [[ "$1" == "--force" ]]; then
        force=true
    fi

    local stale_count=0
    local protected_count=0

    while read -r session; do
        local state=$(detect_session_state "$session")
        local importance=$(get_metadata "$session" "importance")

        if [[ "$state" == "missing" || "$state" == "zombie" ]]; then
            if [[ "$importance" == "critical" && "$force" != "true" ]]; then
                ((protected_count++))
                continue
            fi

            archive_metadata "$session"
            ((stale_count++))
        fi
    done < <(list_metadata)

    echo "Cleaned up $stale_count stale sessions"
    if [[ $protected_count -gt 0 ]]; then
        echo "Skipped $protected_count protected critical sessions (use --force)"
    fi
}

# Clean old archived metadata
# Usage: clean_archive DAYS [--force]
clean_archive() {
    local days="${1:-90}"
    local force=false

    if [[ "$2" == "--force" ]]; then
        force=true
    fi

    if [[ ! -d "$METADATA_ARCHIVE_DIR" ]]; then
        echo "No archive directory found"
        return 0
    fi

    echo "Searching for archive files older than $days days..."

    local count=0
    local total_size=0

    # Find files older than N days
    while IFS= read -r file; do
        local size=$(stat -f%z "$file" 2>/dev/null || echo 0)
        total_size=$((total_size + size))
        ((count++))

        if [[ "$force" == "true" ]]; then
            rm -f "$file"
            echo "  Deleted: $(basename "$file")"
        else
            echo "  Would delete: $(basename "$file")"
        fi
    done < <(find "$METADATA_ARCHIVE_DIR" -name "*.json" -type f -mtime +${days} 2>/dev/null)

    if [[ $count -eq 0 ]]; then
        echo "No files found older than $days days"
        return 0
    fi

    local size_kb=$((total_size / 1024))

    if [[ "$force" == "true" ]]; then
        echo "Deleted $count files ($size_kb KB)"
    else
        echo "Found $count files ($size_kb KB) - use --force to delete"
    fi
}

# CLI interface (when executed directly)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    case "${1:-}" in
        --archive-stale|archive-stale)
            cleanup_stale_metadata "${@:2}"
            ;;
        --clean-archive|clean-archive)
            clean_archive "${@:2}"
            ;;
        --list|list)
            list_metadata
            ;;
        --help|help|-h|"")
            cat << 'EOF'
agent-metadata - Metadata management utilities

USAGE:
  agent-metadata <command> [options]

COMMANDS:
  archive-stale [--force]         Move completed sessions to archive
  clean-archive [DAYS] [--force]  Delete archive files older than DAYS (default: 90)
  list                            List all active metadata files
  help                            Show this help message

EXAMPLES:
  agent-metadata archive-stale           # Move completed sessions to archive
  agent-metadata clean-archive 30        # Show files older than 30 days
  agent-metadata clean-archive 90 --force  # Delete files older than 90 days
  agent-metadata list                    # List active metadata

LOCATIONS:
  Active:  ~/.shelfwood/agent/metadata/
  Archive: ~/.shelfwood/agent/metadata/archive/

EOF
            ;;
        *)
            echo "Unknown command: $1" >&2
            echo "Run 'agent-metadata help' for usage" >&2
            exit 1
            ;;
    esac
fi
