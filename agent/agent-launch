#!/bin/bash
# agent launch - Launch Agent Session
# Creates detached tmux session with copilot running in full autonomy mode
#
# NON-INTERACTIVE: No prompts, no confirmations

set -e

# Source configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../src/lib/config.sh"

# Source metadata utilities
source "$SCRIPT_DIR/agent-metadata"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

usage() {
    cat << EOF
agent launch - Launch new agent session

USAGE:
  agent launch <project-dir> [task-file] [OPTIONS]

ARGUMENTS:
  project-dir   Path to project directory
  task-file     Optional: Task file to reference in initial prompt

OPTIONS:
  --session <name>     Custom session name (default: auto-generated)
  --ttl <minutes>      Auto-kill after N minutes of inactivity (default: 60)
  --no-ttl             Disable auto-shutdown (for long-running tasks)
  --importance <level> Set importance level: normal|critical (default: normal)
  -h, --help           Show this help

EXAMPLES:
  agent launch ~/projects/myapp
  agent launch ~/projects/myapp tasks/refactor.md
  agent launch ~/projects/myapp tasks/refactor.md --session my-task
  agent launch ~/projects/myapp tasks/long-task.md --ttl 180
  agent launch ~/projects/myapp tasks/critical.md --no-ttl --importance critical

BEHAVIOR:
  - Creates detached tmux session
  - Runs copilot with --allow-all-tools --allow-all-paths
  - Git operations requiring confirmation: commit, push, merge, rebase, reset
  - Prepends system instructions from Obsidian vault automatically
  - Sends combined prompt (system instructions + task) if task-file provided
  - Returns immediately (non-blocking)
  - Auto-shutdown after TTL minutes of inactivity (unless --no-ttl)

INACTIVITY DETECTION:
  Agent is considered inactive when tmux pane output stops changing.
  Watchdog checks every minute and kills agents exceeding TTL.
  Use --no-ttl for tasks expected to run >1 hour.
EOF
    exit 0
}

# Parse arguments
PROJECT_DIR=""
TASK_FILE=""
SESSION_NAME=""
TTL_MINUTES=60
IMPORTANCE="normal"

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            usage
            ;;
        --session)
            SESSION_NAME="$2"
            shift 2
            ;;
        --ttl)
            TTL_MINUTES="$2"
            shift 2
            ;;
        --no-ttl)
            TTL_MINUTES=0
            shift
            ;;
        --importance)
            IMPORTANCE="$2"
            if [[ "$IMPORTANCE" != "normal" && "$IMPORTANCE" != "critical" ]]; then
                echo -e "${RED}Error: importance must be 'normal' or 'critical'${NC}"
                exit 1
            fi
            shift 2
            ;;
        *)
            if [[ -z "$PROJECT_DIR" ]]; then
                PROJECT_DIR="$1"
            elif [[ -z "$TASK_FILE" ]]; then
                TASK_FILE="$1"
            else
                echo -e "${RED}Error: Unknown argument: $1${NC}"
                exit 1
            fi
            shift
            ;;
    esac
done

if [[ -z "$PROJECT_DIR" ]]; then
    echo -e "${RED}Error: project-dir required${NC}"
    echo "Usage: agent launch <project-dir> [task-file]"
    exit 1
fi

# Resolve absolute paths
if [[ "$PROJECT_DIR" != /* ]]; then
    PROJECT_DIR="$(cd "$PROJECT_DIR" 2>/dev/null && pwd)"
fi

if [[ -n "$TASK_FILE" ]] && [[ "$TASK_FILE" != /* ]]; then
    CWD="$(pwd)"
    TASK_DIR="$(dirname "$TASK_FILE")"
    TASK_NAME="$(basename "$TASK_FILE")"
    if [[ -d "$CWD/$TASK_DIR" ]]; then
        TASK_FILE="$(cd "$CWD/$TASK_DIR" && pwd)/$TASK_NAME"
    else
        TASK_FILE="$CWD/$TASK_FILE"
    fi
fi

# Validate
if [[ ! -d "$PROJECT_DIR" ]]; then
    echo -e "${RED}Error: Project directory not found: $PROJECT_DIR${NC}"
    exit 1
fi

if [[ -n "$TASK_FILE" ]] && [[ ! -f "$TASK_FILE" ]]; then
    echo -e "${RED}Error: Task file not found: $TASK_FILE${NC}"
    exit 1
fi

# Validate project directory is safe
# Prevent targeting sensitive system directories
case "$PROJECT_DIR" in
    /|/bin|/sbin|/etc|/usr|/System|/Library|/private)
        echo -e "${RED}Error: Cannot launch agent in system directory: $PROJECT_DIR${NC}"
        exit 1
        ;;
    $HOME/.shelfwood/agent*)
        echo -e "${RED}Error: Cannot launch agent in agent infrastructure directory${NC}"
        exit 1
        ;;
esac

# Warn if targeting home directory root
if [[ "$PROJECT_DIR" == "$HOME" ]]; then
    echo -e "${YELLOW}Warning: Launching agent in home directory root${NC}"
    echo -e "${YELLOW}This gives agent access to all your files. Consider using a specific project directory.${NC}"
    # Don't exit, just warn
fi

# Generate session name if not provided
if [[ -z "$SESSION_NAME" ]]; then
    PROJECT_NAME=$(basename "$PROJECT_DIR")
    TIMESTAMP=$(date +%s)
    SESSION_NAME="agent-${PROJECT_NAME}-${TIMESTAMP}"
fi

# Normalize session name (tmux converts dots to underscores)
SESSION_NAME=$(echo "$SESSION_NAME" | tr '.' '_')

# Validate session name format
if ! validate_session_name "$SESSION_NAME"; then
    exit 1
fi

# Check if session already exists
if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    echo -e "${RED}Error: Session '$SESSION_NAME' already exists${NC}"
    exit 1
fi

# Display info
echo -e "${BLUE}╔════════════════════════════════════════════════════════════════╗${NC}"
echo -e "${BLUE}║${NC}  ${GREEN}Launching Agent${NC}                                             ${BLUE}║${NC}"
echo -e "${BLUE}╚════════════════════════════════════════════════════════════════╝${NC}"
echo ""
echo -e "${CYAN}Session:${NC}   $SESSION_NAME"
echo -e "${CYAN}Project:${NC}   $PROJECT_DIR"
if [[ -n "$TASK_FILE" ]]; then
    echo -e "${CYAN}Task:${NC}      $TASK_FILE"
fi
echo ""

# Discover copilot binary with --allow-all-paths support
find_copilot() {
    # Use environment override if set
    if [[ -n "${COPILOT_BIN:-}" ]] && [[ -x "$COPILOT_BIN" ]]; then
        echo "$COPILOT_BIN"
        return 0
    fi

    # Check NVM installations (prefer these - newer versions)
    if [[ -d "$HOME/.nvm/versions/node" ]]; then
        for node_version in "$HOME/.nvm/versions/node/"*/; do
            copilot_path="${node_version}bin/copilot"
            if [[ -x "$copilot_path" ]]; then
                # Verify it supports --allow-all-paths
                if "$copilot_path" --help 2>&1 | grep -q "allow-all-paths"; then
                    echo "$copilot_path"
                    return 0
                fi
            fi
        done
    fi

    # Check PATH copilot as fallback
    if command -v copilot &>/dev/null; then
        copilot_path=$(command -v copilot)
        if "$copilot_path" --help 2>&1 | grep -q "allow-all-paths"; then
            echo "$copilot_path"
            return 0
        fi
    fi

    return 1
}

COPILOT_BIN=$(find_copilot)
if [[ -z "$COPILOT_BIN" ]]; then
    echo -e "${RED}Error: No compatible copilot installation found${NC}"
    echo -e "${YELLOW}Requires GitHub Copilot CLI v0.0.361+ with --allow-all-paths support${NC}"
    echo ""
    echo "Install with npm:"
    echo "  npm install -g @github/copilot@latest"
    echo ""
    echo "Or set COPILOT_BIN environment variable to specific installation"
    exit 1
fi

COPILOT_VERSION=$("$COPILOT_BIN" --version 2>&1 | head -1)
echo -e "${CYAN}Copilot:${NC}   $COPILOT_BIN ($COPILOT_VERSION)"

# Create session with full autonomy
# CRITICAL: tmux must start in PROJECT_DIR, not caller's directory
tmux new-session -d -s "$SESSION_NAME" -c "$PROJECT_DIR" "$COPILOT_BIN --add-dir \"$PROJECT_DIR\" --allow-all-tools --allow-all-paths \
  --deny-tool 'shell(git commit)' \
  --deny-tool 'shell(git push)' \
  --deny-tool 'shell(git merge)' \
  --deny-tool 'shell(git rebase)' \
  --deny-tool 'shell(git reset)' \
  --deny-tool 'shell(gh pr merge)' \
  --deny-tool 'shell(gh pr create)'"
sleep 2

# Create metadata file
PANE_PID=$(tmux list-panes -t "$SESSION_NAME" -F "#{pane_pid}" 2>/dev/null | head -1)
METADATA_FILE=$(create_metadata "$SESSION_NAME" "$PROJECT_DIR" "${TASK_FILE:-}" "$PANE_PID" "$IMPORTANCE" "" "$TTL_MINUTES")

if [[ -z "$METADATA_FILE" ]]; then
    echo -e "${YELLOW}Warning: Failed to create metadata file${NC}"
fi

# Send initial task prompt if provided
if [[ -n "$TASK_FILE" ]]; then
    # Path to system instructions (from config)
    SYSTEM_INSTRUCTIONS="$AGENT_SYSTEM_INSTRUCTIONS_PATH"

    # Build combined prompt with system instructions + task content
    # CRITICAL: Send actual task content, not instruction to read file
    # This triggers Copilot's task_initialization protocol and autonomous execution
    if [[ -n "$SYSTEM_INSTRUCTIONS" && -f "$SYSTEM_INSTRUCTIONS" ]]; then
        COMBINED_PROMPT="# System Instructions

$(cat "$SYSTEM_INSTRUCTIONS")

---

# Task Assignment

$(cat "$TASK_FILE")

[SYSTEM] Task initialization complete... EXECUTING
[EXECUTION] Proceeding with discovery phase immediately per autonomous execution protocol."
    else
        # Fallback if system instructions file not found
        COMBINED_PROMPT="$(cat "$TASK_FILE")

[SYSTEM] Task received... EXECUTING
[EXECUTION] Proceeding with discovery phase immediately per autonomous execution protocol."
    fi

    tmux send-keys -t "$SESSION_NAME" "$COMBINED_PROMPT" C-m
    sleep 2  # Give copilot time to receive the prompt
    tmux send-keys -t "$SESSION_NAME" Enter  # Second Enter to trigger execution
    echo -e "${GREEN}✓ Agent launched with task${NC}"
else
    echo -e "${GREEN}✓ Agent launched (waiting for input)${NC}"
fi

echo ""
echo -e "${YELLOW}Control:${NC}"
echo -e "  agent status $SESSION_NAME"
echo -e "  agent send $SESSION_NAME \"message\""
echo -e "  agent read $SESSION_NAME"
echo -e "  agent kill $SESSION_NAME"
echo ""
